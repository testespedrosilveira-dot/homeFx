<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>HomeFX</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    #p5-holder {
      width: 500px;
      height: 350px;
    }
  </style>
</head>
<body>
<div id="p5-holder"></div>

<script>
new p5((p) => {

  const fileNames = [
    "https://ik.imagekit.io/q3d43lw6h/site/thumb_pp_00331.png",
    "https://ik.imagekit.io/q3d43lw6h/site/CAPA2811_pc1_1.png",
    "https://ik.imagekit.io/q3d43lw6h/site/thumb_fuzzy.png",
    "https://ik.imagekit.io/q3d43lw6h/site/Balma_maleta_mao-2.png",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_005.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_002.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_009.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_003.jpeg"
  ];

  const canvasWidth = 500;
  const canvasHeight = 350;
  const tileSize = 40;
  const maxTiles = 300;
  const marginLeft = 100;
  const marginRight = 100;
  const marginTop = 60;
  const marginBottom = 60;

  let imgs = [];
  let imgsGray = [];
  let tiles = [];

  // --- PRELOAD para garantir que todas imagens estejam carregadas ---
  p.preload = () => {
    for (let f of fileNames) {
      let img = p.loadImage(f);
      imgs.push(img);

      // criar placeholder grayscale
      let g = p.createImage(img.width, img.height);
      g.copy(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);
      g.loadPixels();
      for(let i=0; i<g.pixels.length; i+=4){
        let gray = (g.pixels[i]+g.pixels[i+1]+g.pixels[i+2])/3;
        g.pixels[i] = g.pixels[i+1] = g.pixels[i+2] = gray;
      }
      g.updatePixels();
      imgsGray.push(g);
    }
  };

  function drawImageCover(img, w, h){
    let imgRatio = img.width / img.height;
    let boxRatio = w / h;
    let drawW = w, drawH = h;
    if(imgRatio > boxRatio){
      drawH = h;
      drawW = imgRatio * drawH;
    } else {
      drawW = w;
      drawH = drawW / imgRatio;
    }
    p.image(img, -drawW/2, -drawH/2, drawW, drawH);
  }

  function generateTiles(){
    tiles = [];
    for (let i = 0; i < maxTiles; i++) {
      const px = p.random(marginLeft, canvasWidth - marginRight);
      const py = p.random(marginTop, canvasHeight - marginBottom);
      tiles.push({
        x: px,
        y: py,
        imgColor: imgs[i % imgs.length],
        imgGray: imgsGray[i % imgsGray.length],
        rot: 0,
        scale: 1
      });
    }
  }

  p.setup = () => {
    p.createCanvas(canvasWidth, canvasHeight).parent("p5-holder");
    generateTiles(); // sÃ³ gera depois do preload
  };

  p.draw = () => {
    p.background(255);

    for (let t of tiles) {
      const d = p.dist(p.mouseX, p.mouseY, t.x, t.y);
      let isMain = false;

      // escala diminui quando cursor passa
      if(d < tileSize*2){
        t.rot = p.lerp(t.rot, 0.1, 0.25);
        t.scale = p.lerp(t.scale, 0.7, 0.25);
        isMain = true;
      } else if(d < tileSize*4){
        t.rot = p.lerp(t.rot, 0, 0.15);
        t.scale = p.lerp(t.scale, 0.85, 0.12);
      } else {
        t.rot = p.lerp(t.rot, 0, 0.1);
        t.scale = p.lerp(t.scale, 1.0, 0.1);
      }

      p.push();
      p.translate(t.x, t.y);
      p.rotate(t.rot);
      p.scale(t.scale);
      p.imageMode(p.CENTER);
      if(isMain) drawImageCover(t.imgColor, tileSize, tileSize);
      else drawImageCover(t.imgGray, tileSize, tileSize);
      p.pop();
    }
  };
});
</script>
</body>
</html>
