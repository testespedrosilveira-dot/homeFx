<div id="p5-holder" style="width:700px; height:500px;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script>
new p5((p) => {

  const fileNames = [
    "https://ik.imagekit.io/q3d43lw6h/site/thumb_pp_00331.png",
    "https://ik.imagekit.io/q3d43lw6h/site/CAPA2811_pc1_1.png",
    "https://ik.imagekit.io/q3d43lw6h/site/thumb_fuzzy.png",
    "https://ik.imagekit.io/q3d43lw6h/site/Balma_maleta_mao-2.png",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_005.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_002.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_009.jpeg",
    "https://ik.imagekit.io/q3d43lw6h/site/BudMag_003.jpeg"
  ];

  let imgs = [];
  let imgsGray = [];
  let tiles = [];
  const tileSize = 50;       // tamanho dos tiles
  const tileScale = 1.3;     // escala máxima no hover
  const totalTiles = 180;    // total de tiles
  const offsetX = 200;       // deslocamento horizontal
  const offsetY = 500;       // deslocamento vertical
  let loadedCount = 0;

  // aumenta a densidade de pixels (tela retina)
  p.pixelDensity(2);

  // função para desenhar imagem mantendo proporção
  function drawImageCover(img, w, h){
    const imgRatio = img.width / img.height;
    const boxRatio = w / h;
    let drawW = w, drawH = h;

    if(imgRatio > boxRatio){
      drawH = h;
      drawW = img.width * (drawH / img.height);
    } else {
      drawW = w;
      drawH = img.height * (drawW / img.width);
    }

    p.image(img, -drawW/2, -drawH/2, drawW, drawH);
  }

  // carregar imagens
  fileNames.forEach((url, idx) => {
    p.loadImage(url, (img) => {
      imgs[idx] = img;

      // criar versão grayscale
      let g = p.createImage(img.width, img.height);
      g.copy(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);
      g.loadPixels();
      for(let i=0;i<g.pixels.length;i+=4){
        const gray = (g.pixels[i]+g.pixels[i+1]+g.pixels[i+2])/3;
        g.pixels[i] = g.pixels[i+1] = g.pixels[i+2] = gray;
      }
      g.updatePixels();
      imgsGray[idx] = g;

      loadedCount++;
      if(loadedCount === fileNames.length) generateTiles();
    });
  });

  p.setup = () => {
    p.createCanvas(700, 500).parent("p5-holder"); // tamanho fixo
  };

  p.windowResized = () => {
    p.resizeCanvas(700, 500);
    generateTiles();
  };

  function generateTiles(){
    tiles = [];
    const centerX = p.width/2;
    const centerY = p.height/2;

    for(let i=0;i<totalTiles;i++){
      const angle = p.random(p.TWO_PI);
      const r = Math.sqrt(p.random()) * 0.8; // distância do centro
      const px = centerX + (p.width/2 - tileSize) * r;
      const py = centerY + (p.height/2 - tileSize) * r;
      tiles.push({
        x: px,
        y: py,
        imgColor: imgs[i % imgs.length],
        imgGray: imgsGray[i % imgsGray.length],
        rot: 0,
        scale: 1
      });
    }
  }

  p.draw = () => {
    p.background(255); // fundo branco
    if(loadedCount < fileNames.length) return;

    for(let t of tiles){
      const d = p.dist(p.mouseX, p.mouseY, t.x, t.y);
      let isMain = false;

      if(d < tileSize){ 
        t.scale = p.lerp(t.scale, tileScale, 0.2);
        t.rot = p.lerp(t.rot, 0.1, 0.2);
        isMain = true;
      } else if(d < tileSize*2){ 
        t.scale = p.lerp(t.scale, 0.85, 0.1);
        t.rot = p.lerp(t.rot, 0, 0.1);
      } else { 
        t.scale = p.lerp(t.scale, 1.0, 0.05);
        t.rot = p.lerp(t.rot, 0, 0.05);
      }

      p.push();
      p.translate(t.x + offsetX - 100, t.y + offsetY - 100); // ajusta posição
      p.rotate(t.rot);
      p.scale(t.scale);
      p.imageMode(p.CENTER);
      if(isMain) drawImageCover(t.imgColor, tileSize, tileSize);
      else drawImageCover(t.imgGray, tileSize, tileSize);
      p.pop();
    }
  };
});
</script>
