<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>HomeFX Trail Effect - Rastro Cinza</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: white;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #p5-holder { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div id="p5-holder"></div>
  <script>
    new p5((p) => {

      const fileNames = [
        "https://ik.imagekit.io/q3d43lw6h/site/thumb_pp_00331.png",
        "https://ik.imagekit.io/q3d43lw6h/site/CAPA2811_pc1_1.png",
        "https://ik.imagekit.io/q3d43lw6h/site/thumb_fuzzy.png",
        "https://ik.imagekit.io/q3d43lw6h/site/Balma_maleta_mao-2.png",
        "https://ik.imagekit.io/q3d43lw6h/site/BudMag_005.jpeg",
        "https://ik.imagekit.io/q3d43lw6h/site/BudMag_002.jpeg",
        "https://ik.imagekit.io/q3d43lw6h/site/BudMag_009.jpeg",
        "https://ik.imagekit.io/q3d43lw6h/site/BudMag_003.jpeg"
      ];

      const tileSize = 60;
      const maxTiles = 200;
      const mainRange = tileSize * 3 * 0.8;
      const partialCount = 46;
      const fadeDuration = 500 + 2000;

      let imgs = [];
      let imgsGray = [];
      let tiles = [];
      let loadedCount = 0;

      // Preload imagens
      fileNames.forEach((url, idx) => {
        p.loadImage(url, img => {
          imgs[idx] = img;
          let g = img.get();
          g.filter(p.GRAY);
          imgsGray[idx] = g;
          loadedCount++;
          if (loadedCount === fileNames.length) generateTiles();
        });
      });

      function drawImageCover(img, w, h, alpha = 255) {
        let ratio = img.width / img.height;
        let boxRatio = w / h;
        let drawW = w, drawH = h;
        if (ratio > boxRatio) { drawH = h; drawW = ratio * drawH; }
        else { drawW = w; drawH = drawW / ratio; }
        p.drawingContext.imageSmoothingEnabled = true;
        p.tint(255, alpha);
        p.image(img, -drawW / 2, -drawH / 2, drawW, drawH);
        p.noTint();
      }

      function generateTiles() {
        tiles = [];
        for (let i = 0; i < maxTiles; i++) {
          let grayVal = p.random(50, 255); // escala de cinza
          tiles.push({
            x: p.random(tileSize / 2, p.width - tileSize / 2),
            y: p.random(tileSize / 2, p.height - tileSize / 2),
            imgColor: imgs[i % imgs.length],
            imgGray: imgsGray[i % imgsGray.length],
            rot: 0,
            scale: 1,
            alpha: 0,
            targetAlpha: 0,
            targetScale: 1,
            targetRot: 0,
            grayOverlay: p.color(grayVal, grayVal, grayVal, 0)
          });
        }
      }

      p.setup = () => {
        p.createCanvas(p.windowWidth, p.windowHeight).parent("p5-holder");
      };

      p.windowResized = () => {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
        generateTiles();
      };

      p.draw = () => {
        if (loadedCount < fileNames.length) return;

        let distances = tiles.map((t, i) => ({
          index: i,
          dist: p.dist(p.mouseX, p.mouseY, t.x, t.y)
        }));

        distances.sort((a, b) => a.dist - b.dist);

        let partialIndexes = [];
        for (let i = 0; i < distances.length; i++) {
          if (distances[i].dist > mainRange) {
            partialIndexes.push(distances[i].index);
            if (partialIndexes.length >= partialCount) break;
          }
        }

        tiles.forEach((t, i) => {
          const d = p.dist(p.mouseX, p.mouseY, t.x, t.y);
          const isMain = d < mainRange;
          const isPartial = partialIndexes.includes(i);

          if (isMain) {
            t.targetScale = 1.75;
            t.targetRot = Math.random() * 0.2 - 0.1;
            t.targetAlpha = 255;
          } else if (isPartial) {
            t.targetScale = 1.10;
            t.targetRot = Math.random() * 0.1 - 0.05;
            t.targetAlpha = 18;
          } else {
            t.targetScale = 1;
            t.targetRot = 0;
            t.targetAlpha = 0;
          }

          const dt = p.deltaTime;
          const alphaLerp = dt / 200;
          const scaleLerp = 0.08;

          t.alpha = p.lerp(t.alpha, t.targetAlpha, alphaLerp);
          t.scale = p.lerp(t.scale, t.targetScale, scaleLerp);
          t.rot = p.lerp(t.rot, t.targetRot, scaleLerp);

          if (t.alpha > 0.1) {
            p.push();
            p.translate(t.x, t.y);
            p.rotate(t.rot);
            p.scale(t.scale);

            // Overlay cinza proporcional Ã  opacidade do tile
            let overlayAlpha = p.map(t.alpha, 0, 255, 0, 120);
            t.grayOverlay.setAlpha(overlayAlpha);
            p.noStroke();
            p.fill(t.grayOverlay);
            p.rectMode(p.CENTER);
            p.rect(0, 0, tileSize, tileSize);

            p.imageMode(p.CENTER);
            drawImageCover(isMain ? t.imgColor : t.imgGray, tileSize, tileSize, t.alpha);
            p.pop();
          }
        });
      };
    });
  </script>
</body>
</html>
